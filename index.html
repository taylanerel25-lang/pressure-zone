<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pressure Zone</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;overscroll-behavior:none}
    canvas{display:block;width:100vw;height:100vh;touch-action:none}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    console.log('Script starting');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error('Failed to get 2D context');
      document.body.innerHTML = '<p style="color:white;text-align:center;">Your browser does not support HTML5 Canvas 2D context. Try updating or switching browsers.</p>';
      throw new Error('No 2D context');
    }
    // Make text positions predictable
    ctx.textBaseline = 'top';

    let innerWidthPx, innerHeightPx;

    // player must exist before resize()
    const player = { x: 0, y: 0, vy: 0, r: 18 };

    // ---------- stars (declared before resize to avoid first-frame undefined) ----------
    let starsA = [], starsB = [];
    function initStars() {
      starsA = []; starsB = [];
      for (let i=0;i<60;i++) starsA.push({ x: Math.random()*innerWidthPx, y: Math.random()*innerHeightPx, r: 1 + Math.random() });
      for (let i=0;i<30;i++) starsB.push({ x: Math.random()*innerWidthPx, y: Math.random()*innerHeightPx, r: 1.5 + Math.random()*1.5 });
    }

    function resize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      innerWidthPx  = window.innerWidth;
      innerHeightPx = window.innerHeight;

      player.x = innerWidthPx * 0.5;
      player.y = innerHeightPx * 0.5;

      initStars(); // keep stars in bounds on rotate/resize
      console.log('Resized:', innerWidthPx, 'x', innerHeightPx, 'dpr', dpr);
    }
    addEventListener('resize', resize, { passive:true });
    addEventListener('orientationchange', () => { setTimeout(resize, 100); });
    resize();

    // ---------- input ----------
    let lastTapTime = 0;
    const DEBOUNCE_MS = 60;

    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      const x = e.clientX, y = e.clientY;

      // top-left mute button (50x50)
      if (x < 50 && y < 50) { toggleMute(); return; }

      handleTap();
    }, { passive:false });

    addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.key === 'ArrowUp') {
        e.preventDefault();
        handleTap();
      }
    });

    function handleTap() {
      ensureAudio();
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

      const now = Date.now();
      if (now - lastTapTime < DEBOUNCE_MS) return;
      lastTapTime = now;

      if (state === 'menu' || state === 'gameover') {
        resetGame();
        startGame();
        return;
      }

      if (state === 'playing') {
        player.vy += TAP_IMPULSE;
        playSound('tap');
      }
    }

    // ---------- physics / constants ----------
    const GRAVITY = 1200;
    const TAP_IMPULSE = -360;
    const MAX_FALL = 680;
    const MAX_RISE = -480;
    const SAFE_MARGIN_Y = 64;

    // ---------- audio ----------
    let audioCtx = null;
    let mute = false;
    try { mute = localStorage.getItem('PZ_MUTE') === 'true'; } catch {}

    function ensureAudio() {
      if (!audioCtx) {
        const Ctor = window.AudioContext || window.webkitAudioContext;
        if (!Ctor) return;
        try { audioCtx = new Ctor(); } catch { audioCtx = null; }
      }
    }
    function playSound(type) {
      if (mute) return;
      ensureAudio();
      if (!audioCtx) return;

      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.connect(g); g.connect(audioCtx.destination);

      let freq = 650, dur = 0.04, vol = 0.08, wave = 'sine';
      if (type === 'pass') { freq = 750; dur = 0.05; vol = 0.12; wave = 'square'; }
      if (type === 'die')  { freq = 180; dur = 0.16; vol = 0.25; wave = 'sawtooth'; }

      o.type = wave; o.frequency.value = freq; g.gain.value = vol;
      const t = audioCtx.currentTime;
      o.start(t); o.stop(t + dur);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    }
    function toggleMute() {
      mute = !mute;
      try { localStorage.setItem('PZ_MUTE', mute); } catch {}
      ensureAudio();
    }

    function updateStars(dt) {
      if (!starsA.length || !starsB.length) return; // safety on first tick
      for (const s of starsA) { s.x -= 20*dt; if (s.x < -2) { s.x = innerWidthPx + 2; s.y = Math.random()*innerHeightPx; } }
      for (const s of starsB) { s.x -= 40*dt; if (s.x < -2) { s.x = innerWidthPx + 2; s.y = Math.random()*innerHeightPx; } }
    }
    function drawStars(stars, alpha) {
      if (!stars.length) return;
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = alpha;
      for (const s of stars) { ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); }
      ctx.globalAlpha = 1;
    }

    // ---------- trail + UFO ----------
    let trail = [];
    const TRAIL_LENGTH = 20;

    function updateTrail() {
      trail.push(player.y);
      if (trail.length > TRAIL_LENGTH) trail.shift();
    }
    function roundRectPath(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w,y, x+w,y+h, r);
      ctx.arcTo(x+w,y+h, x,  y+h,  r);
      ctx.arcTo(x,  y+h, x,  y,    r);
      ctx.arcTo(x,  y,   x+w,y,    r);
      ctx.closePath();
    }
    function drawTrail() {
      if (!trail.length) return;
      ctx.strokeStyle = '#fff';
      ctx.globalAlpha = 0.12;
      ctx.beginPath();
      ctx.moveTo(player.x, trail[0]);
      for (let i=1;i<trail.length;i++) ctx.lineTo(player.x, trail[i]);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    function drawUFO() {
      ctx.fillStyle = '#ddd';
      roundRectPath(player.x - 20, player.y - 4, 40, 8, 4); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(player.x, player.y - 6, 12, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.5)';
      ctx.beginPath(); ctx.arc(player.x, player.y, 20, 0, Math.PI*2); ctx.stroke();
    }

    // ---------- obstacles ----------
    let obstacles = [];
    let score = 0;
    let best = 0;
    try { best = parseInt(localStorage.getItem('PZ_BEST_V1') || '0', 10); } catch {}
    let state = 'menu';
    let spawnTimer = 0;
    let speed = 280;
    let spawnEvery = 1.25;
    let gapH = Math.max(140, window.innerHeight * 0.22);
    let flashAlpha = 0;
    const flashDuration = 200;
    let flashStart = 0;
    let t = 0;

    function rand(a,b){ return Math.random()*(b-a)+a; }

    function spawnObstacle() {
      const dir = Math.random() < 0.5 ? 1 : -1;
      const width = innerWidthPx * 0.66;
      const x = dir > 0 ? -width : innerWidthPx + width;
      const margin = 64;
      const gapY = rand(margin + gapH/2, innerHeightPx - margin - gapH/2);
      obstacles.push({ dir, x, speed, gapY, gapH, width, seed: Math.random()*10, _crossed: false });
    }

    function updateObstacles(dt) {
      const lineX = innerWidthPx * 0.5;
      for (let i=obstacles.length-1; i>=0; i--) {
        const o = obstacles[i];
        const prevCenter = o.x + (o.dir > 0 ? o.width*0.5 : -o.width*0.5);
        o.x += o.dir * o.speed * dt;
        o.gapY += Math.sin((t * 0.6) + o.seed) * 12 * dt;
        const m = SAFE_MARGIN_Y + o.gapH/2;
        o.gapY = Math.max(m, Math.min(innerHeightPx - m, o.gapY));
        const center = o.x + (o.dir > 0 ? o.width*0.5 : -o.width*0.5);

        if (!o._crossed && Math.sign(prevCenter - lineX) !== Math.sign(center - lineX)) {
          o._crossed = true;
          const gapTop = o.gapY - o.gapH/2, gapBot = o.gapY + o.gapH/2;

          if (player.y >= gapTop && player.y <= gapBot) {
            score++; playSound('pass');
            if (score > best) { 
              best = score; 
              try { localStorage.setItem('PZ_BEST_V1', best); } catch {}
            }
            if (score % 5 === 0) {
              speed = Math.min(520, speed + 8);
              spawnEvery = Math.max(0.72, spawnEvery - 0.02);
              gapH = Math.max(90, gapH - 4);
            }
          } else {
            gameOver();
          }
        }

        if ((o.dir > 0 && o.x > innerWidthPx + o.width) || (o.dir < 0 && o.x < -o.width)) {
          obstacles.splice(i, 1);
        }
      }
    }

    function drawObstacles() {
      for (const o of obstacles) {
        const left = (o.dir > 0) ? o.x : o.x - o.width;
        const gapTop = o.gapY - o.gapH/2;
        const gapBot = o.gapY + o.gapH/2;

        ctx.fillStyle = '#9aa3ad';
        ctx.fillRect(left, 0, o.width, gapTop);
        ctx.fillRect(left, gapBot, o.width, innerHeightPx - gapBot);

        ctx.strokeStyle = 'rgba(255,255,255,.3)';
        ctx.beginPath();
        ctx.moveTo(left+4, gapTop); ctx.lineTo(left+o.width-4, gapTop);
        ctx.moveTo(left+4, gapBot); ctx.lineTo(left+o.width-4, gapBot);
        ctx.stroke();
      }
    }

    // ---------- game flow / HUD ----------
    function gameOver() {
      state = 'gameover';
      playSound('die');
      flashStart = performance.now();
      flashAlpha = 0.35;
    }

    function updateFlash() {
      if (flashAlpha > 0) {
        const elapsed = performance.now() - flashStart;
        flashAlpha = 0.35 * (1 - elapsed / flashDuration);
        if (flashAlpha < 0) flashAlpha = 0;
      }
    }

    function drawFlash() {
      if (flashAlpha <= 0) return;
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = flashAlpha;
      ctx.fillRect(0,0,innerWidthPx,innerHeightPx);
      ctx.globalAlpha = 1;
    }

    function drawHUD() {
      ctx.font = 'bold 48px sans-serif';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.fillText(String(score), innerWidthPx * 0.5 - (ctx.measureText(String(score)).actualBoundingBoxLeft || 0), 12);

      ctx.font = '24px sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText(`BEST ${best}`, innerWidthPx - 20, 12);

      ctx.textAlign = 'left';
      ctx.fillText(mute ? 'ðŸ”‡' : 'ðŸ”Š', 20, 12);
    }

    function drawOverlay() {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0,0,innerWidthPx,innerHeightPx);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';

      if (state === 'menu') {
        ctx.font = 'bold 48px sans-serif';
        ctx.fillText('PRESSURE ZONE', innerWidthPx*0.5, innerHeightPx*0.4);
        ctx.font = '24px sans-serif';
        ctx.fillText('Tap to start Â· Tap to rise Â· Dodge the junk', innerWidthPx*0.5, innerHeightPx*0.5);
      } else if (state === 'gameover') {
        ctx.font = 'bold 48px sans-serif';
        ctx.fillText(String(score), innerWidthPx*0.5, innerHeightPx*0.4);
        ctx.font = '24px sans-serif';
        ctx.fillText(`BEST ${best}`, innerWidthPx*0.5, innerHeightPx*0.47);
        ctx.fillText('Tap to retry', innerWidthPx*0.5, innerHeightPx*0.54);
      }
    }

    function startGame() {
      state = 'playing';
      spawnTimer = spawnEvery * 0.6; // soon after start
    }

    function resetGame() {
      obstacles = [];
      score = 0;
      spawnTimer = 0;
      speed = 280;
      spawnEvery = 1.25;
      gapH = Math.max(140, innerHeightPx * 0.22);
      player.y = innerHeightPx * 0.5;
      player.vy = 0;
      trail = [];
      flashAlpha = 0;
    }

    // ---------- loop ----------
    let lastTime = performance.now();
    let t = 0;
    function loop(now) {
      try {
        let dt = (now - lastTime) / 1000;
        lastTime = now;
        dt = Math.min(0.033, Math.max(0, dt));
        t += dt;

        // update
        if (state === 'playing') {
          player.vy += GRAVITY * dt;
          if (player.vy >  MAX_FALL) player.vy =  MAX_FALL;
          if (player.vy <  MAX_RISE) player.vy =  MAX_RISE;
          player.y  += player.vy * dt;

          if (player.y - player.r < 0 || player.y + player.r > innerHeightPx) gameOver();

          spawnTimer += dt;
          if (spawnTimer >= spawnEvery) { spawnTimer = 0; spawnObstacle(); }

          updateObstacles(dt);
          updateTrail();
        }

        // draw
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,innerWidthPx,innerHeightPx);
        updateStars(dt);
        drawStars(starsA, 0.5);
        drawStars(starsB, 0.9);
        drawObstacles();
        drawTrail();
        drawUFO();
        drawHUD();
        if (state !== 'playing') drawOverlay();
        updateFlash(); drawFlash();
      } catch (e) {
        console.error('Error in animation loop:', e);
      }
      requestAnimationFrame(loop);
    }
    console.log('Starting animation loop');
    requestAnimationFrame(loop);
  </script>
</body>
</html>
