<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pressure Zone</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;overscroll-behavior:none}
    canvas{display:block;touch-action:none}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // --- SAFEMODE: work around Samsung Internet canvas scaling weirdness
    const isSamsung = /SamsungBrowser|SM-|SAMSUNG|Galaxy/i.test(navigator.userAgent);
    const USE_SAFE_MODE = true; // keep true for now
    const FORCE_DPR_1 = isSamsung && USE_SAFE_MODE;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    if (!ctx) { document.body.innerHTML = '<p style="color:#fff;text-align:center">Canvas unsupported</p>'; throw new Error('No 2D ctx'); }
    ctx.textBaseline = 'top';

    let cssW = 0, cssH = 0;
    const player = { x: 0, y: 0, vy: 0, r: 18 };

    // stars declared early
    let starsA = [], starsB = [];

    function resize() {
      const dpr = FORCE_DPR_1 ? 1 : Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      cssW = Math.max(1, window.innerWidth);
      cssH = Math.max(1, window.innerHeight);

      // In safe mode we DO NOT use setTransform. We size the *bitmap* to CSS px.
      canvas.style.width  = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width  = cssW;   // not multiplied by dpr
      canvas.height = cssH;   // keep 1:1 so Samsung paints

      if (!FORCE_DPR_1) {
        // optional high-DPR path (works on Chrome/Safari/Firefox)
        canvas.width  = Math.floor(cssW * dpr);
        canvas.height = Math.floor(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      } else {
        // reset any prior transform
        ctx.setTransform(1,0,0,1,0,0);
      }

      player.x = cssW * 0.5;
      player.y = cssH * 0.5;

      // rebuild stars
      starsA = []; starsB = [];
      for (let i=0;i<60;i++) starsA.push({ x: Math.random()*cssW, y: Math.random()*cssH, r: 1 + Math.random() });
      for (let i=0;i<30;i++) starsB.push({ x: Math.random()*cssW, y: Math.random()*cssH, r: 1.5 + Math.random()*1.5 });

      // draw a visible test frame immediately
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,cssW,cssH);
      ctx.fillStyle = '#0f0'; ctx.fillRect(0,0,8,8);     // green pixel at top-left
      ctx.fillStyle = '#fff';
      ctx.font = '24px sans-serif';
      ctx.fillText('PRESSURE ZONE — loading…', 12, 12);
    }
    addEventListener('resize', resize, { passive: true });
    addEventListener('orientationchange', () => setTimeout(resize, 100));
    resize();

    // ---------- input ----------
    let lastTapTime = 0;
    const DEBOUNCE_MS = 60;

    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      const x = e.clientX, y = e.clientY;
      if (x < 50 && y < 50) { toggleMute(); return; }
      handleTap();
    }, { passive:false });

    addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.key === 'ArrowUp') { e.preventDefault(); handleTap(); }
    });

    function handleTap() {
      ensureAudio();
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      const now = Date.now(); if (now - lastTapTime < DEBOUNCE_MS) return; lastTapTime = now;

      if (state === 'menu' || state === 'gameover') { resetGame(); startGame(); return; }
      if (state === 'playing') { player.vy += TAP_IMPULSE; playSound('tap'); }
    }

    // ---------- physics / constants ----------
    const GRAVITY = 1200, TAP_IMPULSE = -360, MAX_FALL = 680, MAX_RISE = -480, SAFE_MARGIN_Y = 64;

    // ---------- audio ----------
    let audioCtx = null; let mute = false;
    try { mute = localStorage.getItem('PZ_MUTE') === 'true'; } catch {}
    function ensureAudio(){ if (!audioCtx){ const A = window.AudioContext||window.webkitAudioContext; if(!A)return; try{audioCtx=new A();}catch{audioCtx=null;} } }
    function playSound(type){
      if (mute || !audioCtx) return;
      const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
      let f=650, d=0.04, v=0.08, w='sine';
      if(type==='pass'){f=750;d=0.05;v=0.12;w='square';}
      if(type==='die'){f=180;d=0.16;v=0.25;w='sawtooth';}
      o.type=w; o.frequency.value=f; g.gain.value=v; const t=audioCtx.currentTime; o.start(t); o.stop(t+d); g.gain.exponentialRampToValueAtTime(0.0001,t+d);
    }
    function toggleMute(){ mute=!mute; try{localStorage.setItem('PZ_MUTE', mute);}catch{} ensureAudio(); }

    // ---------- stars ----------
    function updateStars(dt){
      for (const s of starsA){ s.x -= 20*dt; if (s.x < -2){ s.x = cssW + 2; s.y = Math.random()*cssH; } }
      for (const s of starsB){ s.x -= 40*dt; if (s.x < -2){ s.x = cssW + 2; s.y = Math.random()*cssH; } }
    }
    function drawStars(stars, a){
      ctx.fillStyle = '#fff'; ctx.globalAlpha = a;
      for (const s of stars){ ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); }
      ctx.globalAlpha = 1;
    }

    // ---------- trail + UFO ----------
    let trail = []; const TRAIL_LENGTH = 20;
    function updateTrail(){ trail.push(player.y); if (trail.length > TRAIL_LENGTH) trail.shift(); }
    function roundRectPath(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
    function drawTrail(){
      if (!trail.length) return;
      ctx.strokeStyle = '#fff'; ctx.globalAlpha = .12;
      ctx.beginPath(); ctx.moveTo(player.x, trail[0]); for (let i=1;i<trail.length;i++) ctx.lineTo(player.x, trail[i]); ctx.stroke(); ctx.globalAlpha = 1;
    }
    function drawShip() {
      // tilt depends on vertical speed: nose up when rising, down when falling
      const tilt = Math.max(-0.6, Math.min(0.6, -player.vy / 700));

      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(tilt);

      // sizes
      const w = 36, h = 48, r = 10;

      // body
      ctx.fillStyle = '#d9dde2';
      roundRectPath(-w/2, -h/2 + 6, w, h - 12, r);
      ctx.fill();

      // nose cone
      ctx.beginPath();
      ctx.moveTo(0, -h/2 - 8);
      ctx.lineTo(-w*0.45, -h/2 + 10);
      ctx.lineTo( w*0.45, -h/2 + 10);
      ctx.closePath();
      ctx.fillStyle = '#ffffff';
      ctx.fill();

      // window
      ctx.beginPath();
      ctx.arc(0, -6, 7, 0, Math.PI*2);
      ctx.fillStyle = '#9cc7ff';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.85)';
      ctx.stroke();

      // side fins
      ctx.fillStyle = '#ff6961';
      ctx.beginPath();
      ctx.moveTo(-w/2, 4);
      ctx.lineTo(-w/2 - 10, 14);
      ctx.lineTo(-w/2 + 4, 16);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(w/2, 4);
      ctx.lineTo(w/2 + 10, 14);
      ctx.lineTo(w/2 - 4, 16);
      ctx.closePath();
      ctx.fill();

      // tail ring
      ctx.fillStyle = '#b8c0c7';
      roundRectPath(-w*0.35, h/2 - 16, w*0.7, 10, 4);
      ctx.fill();

      // flame (stronger when tapping / going up)
      const up = Math.max(0, -player.vy);     // only when moving up
      const flame = Math.min(28, 8 + up * 0.06);
      if (flame > 0.5) {
        const jitter = (Math.sin(performance.now()*0.02) * 2);
        ctx.beginPath();
        ctx.moveTo(-8, h/2 - 6);
        ctx.lineTo(  8, h/2 - 6);
        ctx.lineTo(  0, h/2 - 6 + flame + jitter);
        ctx.closePath();
        // inner gradient-ish with two fills
        ctx.fillStyle = '#ffb347'; ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-5, h/2 - 6);
        ctx.lineTo( 5, h/2 - 6);
        ctx.lineTo( 0, h/2 - 6 + flame*0.7 + jitter*0.6);
        ctx.closePath();
        ctx.fillStyle = '#ffd1a6'; ctx.fill();
      }

      ctx.restore();
    }

    // keep original UFO function intact (not used now)
    function drawUFO(){
      ctx.fillStyle = '#ddd';
      roundRectPath(player.x - 20, player.y - 4, 40, 8, 4); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(player.x, player.y - 6, 12, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.5)';
      ctx.beginPath(); ctx.arc(player.x, player.y, 20, 0, Math.PI*2); ctx.stroke();
    }

    // ---------- obstacles ----------
    let obstacles = [];
    let score = 0;
    let best = 0; try { best = parseInt(localStorage.getItem('PZ_BEST_V1')||'0',10);}catch{}
    let state = 'menu';
    let spawnTimer = 0;
    let speed = 280;
    let spawnEvery = 1.25;
    let gapH = Math.max(140, cssH * 0.22);
    let flashAlpha = 0;
    const flashDuration = 200;
    let flashStart = 0;
    let t = 0;

    function rand(a,b){ return Math.random()*(b-a)+a; }
    function spawnObstacle(){
      const dir = Math.random() < 0.5 ? 1 : -1;
      const width = cssW * 0.66;
      const x = dir > 0 ? -width : cssW + width;
      const margin = 64;
      const gapY = rand(margin + gapH/2, cssH - margin - gapH/2);
      obstacles.push({ dir, x, speed, gapY, gapH, width, seed: Math.random()*10, _crossed: false });
    }

    function updateObstacles(dt){
      const lineX = cssW * 0.5;
      for (let i=obstacles.length-1; i>=0; i++){
        const o = obstacles[i];
        const prevCenter = o.x + (o.dir > 0 ? o.width*0.5 : -o.width*0.5);
        o.x += o.dir * o.speed * dt;
        o.gapY += Math.sin((t * 0.6) + o.seed) * 12 * dt;
        const m = SAFE_MARGIN_Y + o.gapH/2;
        o.gapY = Math.max(m, Math.min(cssH - m, o.gapY));
        const center = o.x + (o.dir > 0 ? o.width*0.5 : -o.width*0.5);

        if (!o._crossed && Math.sign(prevCenter - lineX) !== Math.sign(center - lineX)) {
          o._crossed = true;
          const gapTop = o.gapY - o.gapH/2, gapBot = o.gapY + o.gapH/2;
          if (player.y >= gapTop && player.y <= gapBot) {
            score++; playSound('pass');
            if (score > best) { best = score; try{ localStorage.setItem('PZ_BEST_V1', best); }catch{} }
            if (score % 5 === 0) { speed = Math.min(520, speed + 8); spawnEvery = Math.max(0.72, spawnEvery - 0.02); gapH = Math.max(90, gapH - 4); }
          } else { gameOver(); }
        }
        if ((o.dir > 0 && o.x > cssW + o.width) || (o.dir < 0 && o.x < -o.width)) obstacles.splice(i, 1);
      }
    }

    function drawObstacles() {
      ctx.fillStyle = '#888'; // Gray for space junk/obstacles
      for (const o of obstacles) {
        const gapTop = o.gapY - o.gapH / 2;
        const gapBot = o.gapY + o.gapH / 2;
        // Top section
        ctx.fillRect(o.x, 0, o.width, gapTop);
        // Bottom section
        ctx.fillRect(o.x, gapBot, o.width, cssH - gapBot);
      }
    }

    // ---------- game flow / HUD ----------
    function gameOver(){ state='gameover'; playSound('die'); flashStart=performance.now(); flashAlpha=0.35; }
    function updateFlash(){ if (flashAlpha>0){ const e=performance.now()-flashStart; flashAlpha=0.35*(1-e/flashDuration); if (flashAlpha<0) flashAlpha=0; } }
    function drawFlash(){ if (flashAlpha<=0) return; ctx.fillStyle='#fff'; ctx.globalAlpha=flashAlpha; ctx.fillRect(0,0,cssW,cssH); ctx.globalAlpha=1; }

    function drawHUD(){
      ctx.font='bold 48px sans-serif'; ctx.fillStyle='#fff'; ctx.textAlign='center';
      ctx.fillText(String(score), Math.floor(cssW*0.5), 12);
      ctx.font='24px sans-serif'; ctx.textAlign='right'; ctx.fillText(`BEST ${best}`, cssW-20, 12);
      ctx.textAlign='left'; ctx.fillText(mute?'🔇':'🔊', 20, 12);
    }

    function drawOverlay(){
      ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,cssW,cssH);
      ctx.fillStyle='#fff'; ctx.textAlign='center';
      if (state==='menu'){
        ctx.font='bold 48px sans-serif'; ctx.fillText('PRESSURE ZONE', cssW*0.5, cssH*0.4);
        ctx.font='24px sans-serif'; ctx.fillText('Tap to start · Tap to rise · Dodge the junk', cssW*0.5, cssH*0.5);
      } else if (state==='gameover'){
        ctx.font='bold 48px sans-serif'; ctx.fillText(String(score), cssW*0.5, cssH*0.4);
        ctx.font='24px sans-serif'; ctx.fillText(`BEST ${best}`, cssW*0.5, cssH*0.47);
        ctx.fillText('Tap to retry', cssW*0.5, cssH*0.54);
      }
    }

    function startGame(){ state='playing'; spawnTimer = spawnEvery * 0.6; }
    function resetGame(){
      obstacles=[]; score=0; spawnTimer=0; speed=280; spawnEvery=1.25; gapH=Math.max(140, cssH*0.22);
      player.y = cssH*0.5; player.vy=0; trail=[]; flashAlpha=0;
    }

    // ---------- loop ----------
    let lastTime = performance.now(); let acc = 0;
    function loop(now){
      try{
        let dt = (now - lastTime)/1000; lastTime = now; dt = Math.min(0.033, Math.max(0, dt)); acc += dt; t += dt;

        // update
        if (state==='playing'){
          player.vy += GRAVITY * dt;
          if (player.vy >  MAX_FALL) player.vy =  MAX_FALL;
          if (player.vy <  MAX_RISE) player.vy =  MAX_RISE;
          player.y  += player.vy * dt;
          if (player.y - player.r < 0 || player.y + player.r > cssH) gameOver();
          spawnTimer += dt; if (spawnTimer >= spawnEvery){ spawnTimer = 0; spawnObstacle(); }
          updateObstacles(dt); updateTrail();
        }

        // draw
        ctx.fillStyle='#000'; ctx.fillRect(0,0,cssW,cssH);
        updateStars(dt); drawStars(starsA,0.5); drawStars(starsB,0.9);
        drawObstacles(); drawTrail();
        drawHUD();
        if (state!=='playing') drawOverlay();
        updateFlash(); drawFlash();

        // draw the ship LAST so it appears above overlays
        drawShip();
      }catch(e){ console.error('Loop error', e); }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
