<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pressure Zone</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover, user-scalable=no">
  <meta name="theme-color" content="#000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Pressure Zone">
  <link rel="manifest" href="manifest.json">
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;overscroll-behavior:none}
    canvas{display:block;touch-action:none}
    html,body,canvas{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // --- SAFEMODE: work around Samsung Internet canvas scaling weirdness
    const isSamsung = /SamsungBrowser|SM-|SAMSUNG|Galaxy/i.test(navigator.userAgent);
    const USE_SAFE_MODE = true; // keep true for now
    const FORCE_DPR_1 = isSamsung && USE_SAFE_MODE;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    if (!ctx) { document.body.innerHTML = '<p style="color:#fff;text-align:center">Canvas unsupported</p>'; throw new Error('No 2D ctx'); }
    ctx.textBaseline = 'top';
    let cssW = 0, cssH = 0;
    const player = { x: 0, y: 0, vy: 0, r: 18 };
    // stars declared early
    let starsA = [], starsB = [];
    function resize() {
      const dpr = FORCE_DPR_1 ? 1 : Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      cssW = Math.max(1, window.innerWidth);
      cssH = Math.max(1, window.innerHeight);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      if (FORCE_DPR_1) {
        canvas.width = cssW; canvas.height = cssH;
        ctx.setTransform(1,0,0,1,0,0);
      } else {
        canvas.width = Math.floor(cssW * dpr);
        canvas.height = Math.floor(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      player.x = cssW * 0.5;
      player.y = cssH * 0.5;
      // rebuild stars
      starsA = []; starsB = [];
      for (let i=0;i<60;i++) starsA.push({ x: Math.random()*cssW, y: Math.random()*cssH, r: 1 + Math.random() });
      for (let i=0;i<30;i++) starsB.push({ x: Math.random()*cssW, y: Math.random()*cssH, r: 1.5 + Math.random()*1.5 });
      // draw a visible test frame immediately
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,cssW,cssH);
      ctx.fillStyle = '#0f0'; ctx.fillRect(0,0,8,8); // green pixel at top-left
      ctx.fillStyle = '#fff';
      ctx.font = '24px sans-serif';
      ctx.fillText('PRESSURE ZONE â€” loadingâ€¦', 12, 12);
    }
    addEventListener('resize', resize, { passive: true });
    addEventListener('orientationchange', () => { setTimeout(resize, 100); isBoosting = false; pressed.clear(); });
    resize();
    // ---------- input ----------
    let isBoosting = false;
    let pressed = new Set();
    canvas.addEventListener('pointerdown', (e) => {
      ensureAudio(); if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      e.preventDefault();
      const x = e.clientX, y = e.clientY;
      if (x < 50 && y < 50) { toggleMute(); return; }
      if (state === 'menu' || state === 'gameover') {
        resetGame(); startGame();
        pressed.clear(); pressed.add(e.pointerId);
        isBoosting = true;
        playSound('tap');
        return;
      }
      // playing
      pressed.add(e.pointerId);
      isBoosting = true;
      playSound('tap');
    }, { passive:false });
    for (const ev of ['pointerup','pointercancel','pointerleave']) {
      canvas.addEventListener(ev, e => {
        pressed.delete(e.pointerId);
        isBoosting = pressed.size > 0;
      });
    }
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    addEventListener('keydown', (e) => {
      ensureAudio(); if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      if (e.key === ' ' || e.key === 'ArrowUp') {
        e.preventDefault();
        if (state === 'menu' || state === 'gameover') { resetGame(); startGame(); }
        isBoosting = true;
        playSound('tap');
      }
    });
    addEventListener('keyup', (e) => {
      if (e.key === ' ' || e.key === 'ArrowUp') {
        e.preventDefault();
        isBoosting = false;
      }
    });
    document.addEventListener('visibilitychange', () => { if (document.hidden) { isBoosting = false; pressed.clear(); } });
    // ---------- physics / constants ----------
    const GRAVITY = 300; // reduced for easier control on mobile
    const BOOST_ACCEL = 600; // adjusted for easier boosting
    const MAX_FALL = 300; // slower max fall
    const MAX_RISE = -300; // slower max rise
    const AIR_DRAG = 0.995;
    const SAFE_MARGIN_Y = 64;
    // ---------- audio ----------
    let audioCtx = null; let mute = false;
    try { mute = localStorage.getItem('PZ_MUTE') === 'true'; } catch {}
    function ensureAudio(){ if (!audioCtx){ const A = window.AudioContext||window.webkitAudioContext; if(!A)return; try{audioCtx=new A();}catch{audioCtx=null;} } }
    function playSound(type){
      if (mute || !audioCtx) return;
      const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
      let f=650, d=0.04, v=0.08, w='sine';
      if(type==='pass'){f=750;d=0.05;v=0.12;w='square';}
      if(type==='die'){f=180;d=0.16;v=0.25;w='sawtooth';}
      o.type=w; o.frequency.value=f; g.gain.value=v; const t=audioCtx.currentTime; o.start(t); o.stop(t+d); g.gain.exponentialRampToValueAtTime(0.0001,t+d);
    }
    function toggleMute(){ mute=!mute; try{localStorage.setItem('PZ_MUTE', mute);}catch{} ensureAudio(); }
    // ---------- stars ----------
    function updateStars(dt){
      for (const s of starsA){ s.x -= 20*dt; if (s.x < -2){ s.x = cssW + 2; s.y = Math.random()*cssH; } }
      for (const s of starsB){ s.x -= 40*dt; if (s.x < -2){ s.x = cssW + 2; s.y = Math.random()*cssH; } }
    }
    function drawStars(stars, a){
      ctx.fillStyle = '#fff'; ctx.globalAlpha = a;
      for (const s of stars){ ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); }
      ctx.globalAlpha = 1;
    }
    // ---------- trail + UFO ----------
    let trail = []; const TRAIL_LENGTH = 20;
    function updateTrail(){ trail.push(player.y); if (trail.length > TRAIL_LENGTH) trail.shift(); }
    function roundRectPath(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
    function drawTrail(){
      if (!trail.length) return;
      ctx.strokeStyle = '#fff'; ctx.globalAlpha = .12;
      ctx.beginPath(); ctx.moveTo(player.x, trail[0]); for (let i=1;i<trail.length;i++) ctx.lineTo(player.x, trail[i]); ctx.stroke(); ctx.globalAlpha = 1;
    }
    function drawShip() {
      // tilt depends on vertical speed: nose up when rising, down when falling
      const tilt = Math.max(-0.6, Math.min(0.6, -player.vy / 700));
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(tilt);
      // sizes
      const w = 36, h = 48, r = 10;
      // body
      ctx.fillStyle = '#d9dde2';
      roundRectPath(-w/2, -h/2 + 6, w, h - 12, r);
      ctx.fill();
      // nose cone
      ctx.beginPath();
      ctx.moveTo(0, -h/2 - 8);
      ctx.lineTo(-w*0.45, -h/2 + 10);
      ctx.lineTo( w*0.45, -h/2 + 10);
      ctx.closePath();
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      // window
      ctx.beginPath();
      ctx.arc(0, -6, 7, 0, Math.PI*2);
      ctx.fillStyle = '#9cc7ff';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.85)';
      ctx.stroke();
      // side fins
      ctx.fillStyle = '#ff6961';
      ctx.beginPath();
      ctx.moveTo(-w/2, 4);
      ctx.lineTo(-w/2 - 10, 14);
      ctx.lineTo(-w/2 + 4, 16);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(w/2, 4);
      ctx.lineTo(w/2 + 10, 14);
      ctx.lineTo(w/2 - 4, 16);
      ctx.closePath();
      ctx.fill();
      // tail ring
      ctx.fillStyle = '#b8c0c7';
      roundRectPath(-w*0.35, h/2 - 16, w*0.7, 10, 4);
      ctx.fill();
      // flame (stronger when tapping / going up)
      const up = Math.max(0, -player.vy); // only when moving up
      const flame = Math.min(28, 8 + up * 0.06);
      if (flame > 0.5) {
        const jitter = (Math.sin(performance.now()*0.02) * 2);
        ctx.beginPath();
        ctx.moveTo(-8, h/2 - 6);
        ctx.lineTo( 8, h/2 - 6);
        ctx.lineTo( 0, h/2 - 6 + flame + jitter);
        ctx.closePath();
        // inner gradient-ish with two fills
        ctx.fillStyle = '#ffb347'; ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-5, h/2 - 6);
        ctx.lineTo( 5, h/2 - 6);
        ctx.lineTo( 0, h/2 - 6 + flame*0.7 + jitter*0.6);
        ctx.closePath();
        ctx.fillStyle = '#ffd1a6'; ctx.fill();
      }
      ctx.restore();
    }
    // keep original UFO function intact (not used now)
    function drawUFO(){
      ctx.fillStyle = '#ddd';
      roundRectPath(player.x - 20, player.y - 4, 40, 8, 4); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(player.x, player.y - 6, 12, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.5)';
      ctx.beginPath(); ctx.arc(player.x, player.y, 20, 0, Math.PI*2); ctx.stroke();
    }
/* ---------- obstacles ---------- */
let obstacles = [];
let score = 0;
let best = 0; try { best = parseInt(localStorage.getItem('PZ_BEST_V1')||'0',10);}catch{}
let state = 'menu';
let spawnTimer = 0;
let speed = 150;
let spawnEvery = 1.5;
let flashAlpha = 0;
const flashDuration = 200;
let flashStart = 0;
let t = 0;
function rand(a,b){ return Math.random()*(b-a)+a; }
function randInt(a,b){ return (Math.random()*(b-a+1) + a)|0; }
function rectCircleOverlap(rx, ry, rw, rh, cx, cy, cr) {
  const dx = cx - Math.max(rx, Math.min(cx, rx + rw));
  const dy = cy - Math.max(ry, Math.min(cy, ry + rh));
  return (dx * dx + dy * dy) <= (cr * cr);
}
function spawnObstacle(){
  const dir = Math.random() < 0.5 ? 1 : -1;
  const isHero = Math.random() < 0.6;
  let width, height;
  if (isHero) {
    width = randInt(36, 92);
    height = randInt(10, 24);
  } else {
    width = randInt(14, 60);
    height = randInt(8, 28);
  }
  const x = dir > 0 ? -width : cssW + width;
  const margin = 32;
  const y = rand(margin + height/2, cssH - margin - height/2);
  const hl = !isHero && Math.random() < 0.2;
  const seed = Math.random()*10;
  obstacles.push({ dir, x, y, width, height, speed, seed, _crossed: false, hero: isHero, hl });
}
function updateObstacles(dt){
  const playerRight = player.x + player.r;
  const playerLeft = player.x - player.r;
  for (let i=obstacles.length-1; i>=0; i--){
    const o = obstacles[i];
    o.x += o.dir * o.speed * dt;
    o.y += Math.sin((t * 0.6) + o.seed) * 12 * dt;
    const m = o.height/2 + SAFE_MARGIN_Y;
    o.y = Math.max(m, Math.min(cssH - m, o.y));
    // On-screen bounds
    const obsLeft = (o.dir > 0) ? o.x : o.x - o.width;
    const obsRight = obsLeft + o.width;
    const isVisible = obsLeft < cssW && obsRight > 0;
    // Only collide once the junk is actually visible on screen
    if (isVisible && rectCircleOverlap(obsLeft, o.y - o.height/2, o.width, o.height, player.x, player.y, player.r)) {
      gameOver();
    }
    // Score when fully cleared
    const prevObsLeft = (o.dir > 0) ? (o.x - o.dir * o.speed * dt) : (o.x - o.dir * o.speed * dt) - o.width;
    const prevObsRight = prevObsLeft + o.width;
    if (!o._crossed &&
        ((o.dir > 0 && prevObsLeft <= playerRight && obsLeft > playerRight) ||
         (o.dir < 0 && prevObsRight >= playerLeft && obsRight < playerLeft))) {
      o._crossed = true;
      score++; playSound('pass');
      if (score > best) { best = score; try{ localStorage.setItem('PZ_BEST_V1', best); }catch{} }
      if (score % 5 === 0) { speed = Math.min(300, speed + 5); spawnEvery = Math.max(1.0, spawnEvery - 0.01); }
    }
    // Despawn when gone
    if (obsRight < -2 || obsLeft > cssW + 2) obstacles.splice(i, 1);
  }
}
function drawObstacles() {
  for (const o of obstacles) {
    const baseX = (o.dir > 0) ? o.x : o.x - o.width;
    const py = o.y - o.height / 2;
    if (baseX > cssW || baseX + o.width < 0) continue; // cull off-screen
    if (o.hero) {
      ctx.fillStyle = '#cfd6e3';
      ctx.fillRect(baseX, py, o.width, o.height);
      ctx.strokeStyle = 'rgba(255,255,255,.25)';
      ctx.strokeRect(baseX, py, o.width, o.height);
      for (let k=1;k<3;k++){
        ctx.beginPath();
        ctx.moveTo(baseX + k*(o.width/3), py-6);
        ctx.lineTo(baseX + k*(o.width/3), py + o.height + 6);
        ctx.stroke();
      }
    } else {
      ctx.fillStyle = '#8893a3';
      ctx.fillRect(baseX, py, o.width, o.height);
      if (o.hl) {
        ctx.fillStyle = 'rgba(255,255,255,.12)';
        ctx.fillRect(baseX+2, py+2, Math.max(0,o.width-4), Math.max(0,o.height-4));
      }
    }
  }
}
    // ---------- game flow / HUD ----------
    function gameOver(){ state='gameover'; playSound('die'); flashStart=performance.now(); flashAlpha=0.35; isBoosting = false; pressed.clear(); }
    function updateFlash(){ if (flashAlpha>0){ const e=performance.now()-flashStart; flashAlpha=0.35*(1-e/flashDuration); if (flashAlpha<0) flashAlpha=0; } }
    function drawFlash(){ if (flashAlpha<=0) return; ctx.fillStyle='#fff'; ctx.globalAlpha=flashAlpha; ctx.fillRect(0,0,cssW,cssH); ctx.globalAlpha=1; }
    function drawHUD(){
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      const HUD_Y = isMobile ? 40 : 12;
      const isSmallScreen = cssW < 600;
      ctx.font= (isSmallScreen ? 'bold 32px' : 'bold 48px') + ' monospace'; ctx.fillStyle='#fff'; ctx.textAlign='center';
      ctx.fillText(String(score), Math.floor(cssW*0.5), HUD_Y);
      ctx.font= (isSmallScreen ? '18px' : '24px') + ' monospace'; ctx.textAlign='right'; ctx.fillText(`BEST ${best}`, cssW-20, HUD_Y);
      ctx.textAlign='left'; ctx.fillText(mute?'ðŸ”‡':'ðŸ”Š', 20, HUD_Y);
    }
    function drawOverlay(){
      if (state==='menu'){
        ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,cssW,cssH);
      }
      ctx.fillStyle='#fff'; ctx.textAlign='center';
      if (state==='menu'){
        // No dim overlay for retro look
        ctx.font = '20px monospace';
        ctx.fillText('1P', cssW*0.15, 20);
        ctx.fillText('00', cssW*0.15, 45);
        ctx.fillText('HIGH SCORE', cssW*0.5, 20);
        ctx.fillText(best, cssW*0.5, 45);
        ctx.fillText('2P', cssW*0.85, 20);
        ctx.fillText('00', cssW*0.85, 45);
        ctx.fillStyle = '#ff8c00';
        ctx.font = 'bold 48px monospace';
        ctx.fillText('PRESS START', cssW*0.5, cssH*0.35);
        ctx.fillStyle = '#fff';
        ctx.font = '24px monospace';
        ctx.fillText('INSERT COIN TO CONTINUE', cssW*0.5, cssH*0.45);
        ctx.font = '20px monospace';
        ctx.fillText('CREDIT 00', cssW*0.85, cssH - 30);
        ctx.fillText('Hold to rise Â· Release to fall Â· Dodge the junk', cssW*0.5, cssH*0.55);
      } else if (state==='gameover'){
        ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,cssW,cssH);
        ctx.fillStyle='#fff';
        ctx.font='bold 48px monospace'; ctx.fillText(String(score), cssW*0.5, cssH*0.4);
        ctx.font='24px monospace'; ctx.fillText(`BEST ${best}`, cssW*0.5, cssH*0.47);
        ctx.fillText('Tap to retry', cssW*0.5, cssH*0.54);
      }
    }
    function startGame(){ state='playing'; spawnTimer = spawnEvery * 0.6; }
    function resetGame(){
      obstacles=[]; score=0; spawnTimer=0; speed=150; spawnEvery=1.5;
      player.y = cssH*0.5; player.vy=0; trail=[]; flashAlpha=0; isBoosting = false; pressed.clear();
    }
    // ---------- loop ----------
    let lastTime = performance.now();
    function loop(now){
      try{
        let dt = (now - lastTime)/1000; lastTime = now; dt = Math.min(0.033, Math.max(0, dt)); t += dt;
        // update
        if (state==='playing'){
          player.vy += GRAVITY * dt;
          if (isBoosting) player.vy -= BOOST_ACCEL * dt;
          player.vy *= AIR_DRAG;
          if (player.vy > MAX_FALL) player.vy = MAX_FALL;
          if (player.vy < MAX_RISE) player.vy = MAX_RISE;
          player.y += player.vy * dt;
          if (player.y - player.r < 0 || player.y + player.r > cssH) gameOver();
          spawnTimer += dt; if (spawnTimer >= spawnEvery){ spawnTimer = 0; spawnObstacle(); }
          updateObstacles(dt); updateTrail();
        }
        // draw
        ctx.fillStyle='#000'; ctx.fillRect(0,0,cssW,cssH);
        updateStars(dt); drawStars(starsA,0.5); drawStars(starsB,0.9);
        drawObstacles(); drawTrail();
        drawHUD();
        if (state!=='playing') drawOverlay();
        updateFlash(); drawFlash();
        // draw the ship LAST so it appears above overlays
        drawShip();
      }catch(e){ console.error('Loop error', e); }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
  <script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').catch(()=>{});
  }
  </script>
</body>
</html>
